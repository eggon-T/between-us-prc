-- RESTORE TABLES SCRIPT
-- Restores 'likes', 'matches', 'hint_counter', 'anonymous_hints'
-- Removes conflicting 'choices' table and 'matches' view

-- 1. CLEANUP: Drop conflicting objects
DROP VIEW IF EXISTS public.matches;
DROP TABLE IF EXISTS public.choices CASCADE;
DROP TABLE IF EXISTS public.matches CASCADE; -- Ensure it's gone if it was a table
DROP TABLE IF EXISTS public.likes CASCADE;
DROP TABLE IF EXISTS public.hint_counter CASCADE;
DROP TABLE IF EXISTS public.anonymous_hints CASCADE;

-- 2. CREATE TABLES

-- A. LIKES
CREATE TABLE public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (from_user, to_user),
  CHECK (from_user <> to_user)
);
CREATE INDEX idx_likes_to_from ON public.likes(to_user, from_user);
CREATE INDEX idx_likes_from_to ON public.likes(from_user, to_user);
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own sent likes" ON public.likes FOR SELECT USING (auth.uid() = from_user);


-- B. MATCHES (The real table, not view)
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user1 UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  user2 UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user1, user2),
  CHECK (user1 < user2)
);
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;
-- Strict Time-Gated Policy for Matches (from secure_reveal.sql)
CREATE POLICY "Users can view matches ONLY after deadline"
ON public.matches FOR SELECT
USING (
  (auth.uid() = user1 OR auth.uid() = user2)
  AND
  (NOW() >= '2026-02-13 18:30:00+00') -- 2026-02-14 00:00:00 IST
);


-- C. HINT COUNTER
CREATE TABLE public.hint_counter (
  user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
  count INT DEFAULT 0
);
ALTER TABLE public.hint_counter ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own hint count" ON public.hint_counter FOR SELECT USING (auth.uid() = user_id);


-- D. ANONYMOUS HINTS
CREATE TABLE public.anonymous_hints (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  hint_text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CHECK (from_user <> to_user),
  CHECK (char_length(hint_text) > 0 AND char_length(hint_text) <= 200)
);
CREATE INDEX idx_hints_to_user ON public.anonymous_hints(to_user, created_at DESC);
CREATE INDEX idx_hints_from_user ON public.anonymous_hints(from_user);
ALTER TABLE public.anonymous_hints ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view received hints" ON public.anonymous_hints FOR SELECT USING (auth.uid() = to_user);


-- 3. FUNCTIONS

-- Helper: Lock ID
CREATE OR REPLACE FUNCTION get_lock_id(u1 UUID, u2 UUID)
RETURNS BIGINT AS $$
DECLARE
  first_uuid UUID := LEAST(u1, u2);
  second_uuid UUID := GREATEST(u1, u2);
BEGIN
  RETURN hashtext(first_uuid::text || second_uuid::text);
END;
$$ LANGUAGE plpgsql IMMUTABLE;


-- Helper: Get Reveal Status (Single Source of Truth)
CREATE OR REPLACE FUNCTION get_reveal_status()
RETURNS jsonb AS $$
DECLARE
  deadline TIMESTAMPTZ := '2026-02-13 18:30:00+00';
  now_time TIMESTAMPTZ := NOW();
  is_revealed BOOLEAN;
BEGIN
  is_revealed := now_time >= deadline;
  RETURN jsonb_build_object(
    'server_time', now_time,
    'deadline', deadline,
    'is_revealed', is_revealed
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Helper: Get My Selections
CREATE OR REPLACE FUNCTION get_my_selections()
RETURNS TABLE (selected_user_id UUID) AS $$
DECLARE
  curr_uid UUID;
BEGIN
  curr_uid := auth.uid();
  RETURN QUERY
    SELECT to_user FROM public.likes WHERE from_user = curr_uid
    UNION ALL
    SELECT user2 FROM public.matches WHERE user1 = curr_uid
    UNION ALL
    SELECT user1 FROM public.matches WHERE user2 = curr_uid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Core: Select User (with Locking & Deadline)
CREATE OR REPLACE FUNCTION select_user(target_id UUID)
RETURNS VOID AS $$
DECLARE
  current_uid UUID;
  u1 UUID;
  u2 UUID;
  existing_like_count INT;
  existing_match_count INT;
BEGIN
  -- Deadline Check (1:00 AM IST on Feb 14 = Feb 13 19:30 UTC)
  IF NOW() > '2026-02-13 19:30:00+00' THEN
    RAISE EXCEPTION 'Detailed selection period ended at 1:00 AM on Feb 14';
  END IF;

  current_uid := auth.uid();

  IF current_uid = target_id THEN
    RAISE EXCEPTION 'Cannot select yourself';
  END IF;

  -- Advisory Lock
  PERFORM pg_advisory_xact_lock(get_lock_id(current_uid, target_id));

  -- Max 5 check
  SELECT count(*) INTO existing_like_count FROM public.likes WHERE from_user = current_uid;
  SELECT count(*) INTO existing_match_count FROM public.matches WHERE user1 = current_uid OR user2 = current_uid;

  IF (existing_like_count + existing_match_count) >= 5 THEN
    RAISE EXCEPTION 'Maximum selections reached';
  END IF;

  -- Check if already selected
  IF EXISTS (SELECT 1 FROM public.likes WHERE from_user = current_uid AND to_user = target_id) THEN
     RETURN; 
  END IF;
  
  u1 := LEAST(current_uid, target_id);
  u2 := GREATEST(current_uid, target_id);

  IF EXISTS (SELECT 1 FROM public.matches WHERE user1 = u1 AND user2 = u2) THEN
     RETURN;
  END IF;

  -- Check reverse like
  IF EXISTS (SELECT 1 FROM public.likes WHERE from_user = target_id AND to_user = current_uid) THEN
    -- MATCH FOUND
    INSERT INTO public.matches (user1, user2) VALUES (u1, u2);
    DELETE FROM public.likes WHERE from_user = target_id AND to_user = current_uid;
    
    -- Decrement hint counter for ME
    UPDATE public.hint_counter
    SET count = GREATEST(0, count - 1)
    WHERE user_id = current_uid;
  ELSE
    -- NO MATCH YET
    INSERT INTO public.likes (from_user, to_user) VALUES (current_uid, target_id);
    -- Increment hint counter for TARGET
    INSERT INTO public.hint_counter (user_id, count) VALUES (target_id, 1)
    ON CONFLICT (user_id) DO UPDATE SET count = hint_counter.count + 1;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Core: Deselect User
CREATE OR REPLACE FUNCTION deselect_user(target_id UUID)
RETURNS VOID AS $$
DECLARE
  current_uid UUID;
  u1 UUID;
  u2 UUID;
BEGIN
  -- Deadline Check
  IF NOW() > '2026-02-13 19:30:00+00' THEN
    RAISE EXCEPTION 'Selection locked. You cannot remove likes now.';
  END IF;

  current_uid := auth.uid();
  u1 := LEAST(current_uid, target_id);
  u2 := GREATEST(current_uid, target_id);

  -- Advisory Lock
  PERFORM pg_advisory_xact_lock(get_lock_id(current_uid, target_id));

  -- Scenario A: Match
  IF EXISTS (SELECT 1 FROM public.matches WHERE user1 = u1 AND user2 = u2) THEN
    DELETE FROM public.matches WHERE user1 = u1 AND user2 = u2;
    -- Restore OTHER person's like
    INSERT INTO public.likes (from_user, to_user) VALUES (target_id, current_uid) ON CONFLICT DO NOTHING;
    -- Increment MY hint counter
    INSERT INTO public.hint_counter (user_id, count) VALUES (current_uid, 1)
    ON CONFLICT (user_id) DO UPDATE SET count = hint_counter.count + 1;

  -- Scenario B: Like
  ELSIF EXISTS (SELECT 1 FROM public.likes WHERE from_user = current_uid AND to_user = target_id) THEN
    DELETE FROM public.likes WHERE from_user = current_uid AND to_user = target_id;
    -- Decrement TARGET's hint counter
    UPDATE public.hint_counter SET count = GREATEST(0, count - 1) WHERE user_id = target_id;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Core: Send Anonymous Hint
CREATE OR REPLACE FUNCTION send_anonymous_hint(target_id UUID, hint_message TEXT)
RETURNS jsonb AS $$
DECLARE
  current_uid UUID;
  has_selected BOOLEAN;
BEGIN
  current_uid := auth.uid();
  
  IF current_uid = target_id THEN
    RAISE EXCEPTION 'Cannot send hint to yourself';
  END IF;
  
  -- Must have selected
  SELECT EXISTS (
    SELECT 1 FROM public.likes WHERE from_user = current_uid AND to_user = target_id
    UNION
    SELECT 1 FROM public.matches WHERE 
      (user1 = LEAST(current_uid, target_id) AND user2 = GREATEST(current_uid, target_id))
  ) INTO has_selected;
  
  IF NOT has_selected THEN
    RAISE EXCEPTION 'You can only send hints to people you have selected';
  END IF;
  
  IF char_length(hint_message) = 0 OR char_length(hint_message) > 200 THEN
    RAISE EXCEPTION 'Hint must be between 1 and 200 characters';
  END IF;
  
  INSERT INTO public.anonymous_hints (from_user, to_user, hint_text)
  VALUES (current_uid, target_id, hint_message);
  
  RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Helper: Get My Hints
CREATE OR REPLACE FUNCTION get_my_hints()
RETURNS TABLE (hint_text TEXT, created_at TIMESTAMPTZ) AS $$
BEGIN
  RETURN QUERY
  SELECT h.hint_text, h.created_at
  FROM public.anonymous_hints h
  WHERE h.to_user = auth.uid()
  ORDER BY h.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 4. GRANT PERMISSIONS
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated, service_role;
