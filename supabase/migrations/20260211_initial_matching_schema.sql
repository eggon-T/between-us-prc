-- Migration to O(1) Write-Time Matching Architecture

-- 1. Create 'likes' table
CREATE TABLE IF NOT EXISTS public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (from_user, to_user),
  CHECK (from_user <> to_user)
);

-- Indexes for O(1) lookups
CREATE INDEX IF NOT EXISTS idx_likes_to_from ON public.likes(to_user, from_user);
CREATE INDEX IF NOT EXISTS idx_likes_from_to ON public.likes(from_user, to_user);

-- Enable RLS on likes
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Users can read likes where they are the sender (to know who they selected)
CREATE POLICY "Users can view own sent likes" ON public.likes
  FOR SELECT USING (auth.uid() = from_user);

-- 2. Create 'matches' table
CREATE TABLE IF NOT EXISTS public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user1 UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  user2 UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user1, user2),
  CHECK (user1 < user2) -- Enforce user1 < user2 to avoid duplicates like (A,B) and (B,A)
);

-- Enable RLS on matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;

-- Users can read matches where they are involved
CREATE POLICY "Users can view own matches" ON public.matches
  FOR SELECT USING (auth.uid() = user1 OR auth.uid() = user2);

-- 3. Create 'hint_counter' table
CREATE TABLE IF NOT EXISTS public.hint_counter (
  user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
  count INT DEFAULT 0
);

-- Enable RLS on hint_counter
ALTER TABLE public.hint_counter ENABLE ROW LEVEL SECURITY;

-- Users can read their own hint count
CREATE POLICY "Users can view own hint count" ON public.hint_counter
  FOR SELECT USING (auth.uid() = user_id);


-- 4. RPC Function: select_user (The Core Logic)
CREATE OR REPLACE FUNCTION select_user(target_id UUID)
RETURNS VOID AS $$
DECLARE
  current_uid UUID;
  u1 UUID;
  u2 UUID;
  existing_like_count INT;
  existing_match_count INT;
BEGIN
  current_uid := auth.uid();

  -- Self-like check
  IF current_uid = target_id THEN
    RAISE EXCEPTION 'Cannot select yourself';
  END IF;

  -- Check max 5 selections (likes + matches) - O(1)ish
  SELECT count(*) INTO existing_like_count FROM public.likes WHERE from_user = current_uid;
  SELECT count(*) INTO existing_match_count FROM public.matches WHERE user1 = current_uid OR user2 = current_uid;

  IF (existing_like_count + existing_match_count) >= 5 THEN
    RAISE EXCEPTION 'Maximum selections reached';
  END IF;

  -- Check if already selected (idempotency/prevention)
  IF EXISTS (SELECT 1 FROM public.likes WHERE from_user = current_uid AND to_user = target_id) THEN
     RETURN; -- Already liked
  END IF;
  
  u1 := LEAST(current_uid, target_id);
  u2 := GREATEST(current_uid, target_id);

  IF EXISTS (SELECT 1 FROM public.matches WHERE user1 = u1 AND user2 = u2) THEN
     RETURN; -- Already matched
  END IF;


  -- Step 1: Check reverse like (Did target already like me?)
  IF EXISTS (SELECT 1 FROM public.likes WHERE from_user = target_id AND to_user = current_uid) THEN
    -- MATCH FOUND!
    
    -- 1. Create match
    INSERT INTO public.matches (user1, user2) VALUES (u1, u2);
    
    -- 2. Remove the pending like from target -> me
    DELETE FROM public.likes WHERE from_user = target_id AND to_user = current_uid;
    
    -- 3. Decrement hint counter for ME (since my anonymous like became a match)
    UPDATE public.hint_counter
    SET count = GREATEST(0, count - 1)
    WHERE user_id = current_uid;

    -- (No changes to target's hint counter needed because I hadn't liked them yet, 
    --  and now we are matched, so I don't contribute to their anonymous count either)

  ELSE
    -- NO MATCH YET -> Just store the like
    INSERT INTO public.likes (from_user, to_user) VALUES (current_uid, target_id);

    -- Increment hint counter for TARGET using UPSERT
    INSERT INTO public.hint_counter (user_id, count)
    VALUES (target_id, 1)
    ON CONFLICT (user_id)
    DO UPDATE SET count = hint_counter.count + 1;

  END IF;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 5. RPC Function: deselect_user (The Undo Logic)
CREATE OR REPLACE FUNCTION deselect_user(target_id UUID)
RETURNS VOID AS $$
DECLARE
  current_uid UUID;
  u1 UUID;
  u2 UUID;
BEGIN
  current_uid := auth.uid();
  u1 := LEAST(current_uid, target_id);
  u2 := GREATEST(current_uid, target_id);

  -- Scenario A: It was a Match ?
  IF EXISTS (SELECT 1 FROM public.matches WHERE user1 = u1 AND user2 = u2) THEN
    -- 1. Remove match
    DELETE FROM public.matches WHERE user1 = u1 AND user2 = u2;
    
    -- 2. Restore the OTHER person's like (since they still like me)
    INSERT INTO public.likes (from_user, to_user) VALUES (target_id, current_uid);
    
    -- 3. Increment MY hint counter (since I now have an anonymous like again)
    INSERT INTO public.hint_counter (user_id, count)
    VALUES (current_uid, 1)
    ON CONFLICT (user_id)
    DO UPDATE SET count = hint_counter.count + 1;

    -- (I am removed completely, so no impact on target's hint count)

  -- Scenario B: It was just a Like ?
  ELSIF EXISTS (SELECT 1 FROM public.likes WHERE from_user = current_uid AND to_user = target_id) THEN
    -- 1. Remove like
    DELETE FROM public.likes WHERE from_user = current_uid AND to_user = target_id;
    
    -- 2. Decrement TARGET's hint counter
    UPDATE public.hint_counter
    SET count = GREATEST(0, count - 1)
    WHERE user_id = target_id;
  
  END IF;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Helper: get_my_selections (For Select Page UI to know who is 'hearted')
-- Returns list of user IDs that current user likes OR matches with
CREATE OR REPLACE FUNCTION get_my_selections()
RETURNS TABLE (selected_user_id UUID) AS $$
DECLARE
  curr_uid UUID;
BEGIN
  curr_uid := auth.uid();
  
  RETURN QUERY
    -- From Likes
    SELECT to_user FROM public.likes WHERE from_user = curr_uid
    UNION ALL
    -- From Matches (User1)
    SELECT user2 FROM public.matches WHERE user1 = curr_uid
    UNION ALL
    -- From Matches (User2)
    SELECT user1 FROM public.matches WHERE user2 = curr_uid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
